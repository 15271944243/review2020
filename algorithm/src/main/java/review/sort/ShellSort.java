package review.sort;

import review.utils.StrUtils;

/**
 * 希尔排序
 * @author: xiaoxiaoxiang
 * @date: 2020/10/20 17:45
 */
public class ShellSort {

    /**
     * 希尔排序:
     * 时间复杂度(平均): O(n^1.3)
     * 时间复杂度(最坏): O(n^2)
     * 时间复杂度(最好): O(n)
     * 空间复杂度: O(1)
     * 稳定性: 稳定
     *
     * - 稳定: 如果a原本在b前面,而a=b,排序之后a仍然在b的前面
     * - 不稳定: 如果a原本在b的前面,而a=b,排序之后 a 可能会出现在 b 的后面
     */

    public static void main(String[] args) {
        ShellSort shellSort = new ShellSort();
        int[] a = {50,55,89,103,77,99,86,43,64,15,22,30,40,60,30,14,28,77,10,20};
        shellSort.shellSort(a);
        System.out.println(StrUtils.arrayToString(a, ","));
    }



    /**
     * 第一个突破O(n^2)的排序算法,是插入排序的改进版.
     * 它与插入排序的不同之处在于,它会优先比较距离较远的元素.
     * 希尔排序又叫缩小增量排序.
     *
     * 希尔排序是基于插入排序的以下两点性质而提出的改进方法：
     * 1. 插入排序在对几乎已经排好序的数据操作时,效率高,即可以达到线性排序的效率
     * 2. 插入排序一般来说是低效的,因为插入排序每次比较只能将数据移动一位
     *
     * 原理:
     * 希尔排序是将待排序的数组元素按下标的一定增量分组,分成多个子数组,然后对各个子数组进行直接插入排序算法排序;
     * 然后依次缩减增量再进行排序,直到增量为1时,进行最后一次直接插入排序,排序结束
     *
     * 步骤:
     * 1. 选择一个增量序列t1，t2，…，tk，其中ti>tj, tk=1
     * 2. 按增量序列个数k,对序列进行k趟排序
     * 3. 每趟排序,根据对应的增量ti,将待排序列分割成若干长度为m的子序列,
     * 分别对各子序列进行直接插入排序.仅增量因子为1时,整个序列作为一个表来处理,表长度即为整个序列的长度
     *
     * 如何选择增量序列:
     * 增量 d 的范围: 1<= d < 待排序数组的长度 （d 需为 int 值）
     * 增量的取值: 一般的初次取序列（数组）的一半为增量,以后每次减半,直到增量为1
     * 第一个增量=数组的长度/2,
     * 第二个增量=第一个增量/2,
     * 第三个增量=第二个增量/2,
     * 以此类推，最后一个增量=1。
     */
    public void shellSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int d = arr.length / 2;
        // 第一层循环,针对增量d的循环
        while (d > 0) {
            // 第二层循环,根据d分成子数组
            // 从d开始,因为[0~d)相当于每个子数组的第一个插入元素
            for (int i=d;i<arr.length;i++) {
                // 第三层循环,插入排序,arr[i]即为被插入的元素,与前面的元素依次
                for (int j=i;j>=d;j=j-d) {
                    if (arr[j] < arr[j-d]) {
                        StrUtils.swap(arr, j, j-d);
                    }
                }
            }
            d = d / 2;
        }
    }
}
