### 01背包
有N件物品和一个最多能被重量为W的背包,第i件物品的重量是weight[i],得到的价值是value[i]  
每件物品只能用一次,求解将哪些物品装入背包里物品价值总和最

> 因为每个物品只能使用一次,所以叫01背包

背包问题,除了暴力解法外,可以使用动态规划
#### 二维DP数组解法
https://mp.weixin.qq.com/s/FwIiPPmR18_AJO5eiidT6w

对于背包问题,有一种解法,是使用二维数组,即dp[i][j]表示从下标为[0-i]的物品里任意取,
放进容量为j的背包,价值总和最大是多少大

1.确定dp数组以及下标的含义

dp[i][j]表示从下标为[0-i]的物品里任意取,放进容量为j的背包,价值总和最大是多少大

2.确定递推公式
- 由dp[i - 1][j]推出,即背包容量为j,里面不放物品i的最大价值,此时dp[i][j]就是dp[i - 1][j]
- 由dp[i - 1][j - weight[i]]推出,dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值,
那么dp[i - 1][j - weight[i]] + value[i] (物品i的价值),就是背包放物品i得到的最大价值

所以递归公式(状态转移方程)：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

3.dp数组如何初始化

- 如果背包容量j为0的话,即dp[i][0],无论是选取哪些物品,背包价值总和一定为0
- i 是由 i-1 推导出来,那么i为0的时候就一定要初始化: dp[0][j],即i为0,存放编号0的物品的时候,各个容量的背包所能存放的最大价值
```
// 倒叙遍历  
for (int j = bagWeight; j >= weight[0]; j--) {  
    dp[0][j] = dp[0][j - weight[0]] + value[0]; // 初始化i为0时候的情况  
}
```
一定要倒叙遍历,保证物品0只被放入一次

4.确定遍历顺序

有两个遍历的维度: 物品与背包重量  
先遍历物品还是先遍历背包重量呢？ 其实都可以,但是先遍历物品更好理解

#### 一维dp数组（滚动数组）解法

https://mp.weixin.qq.com/s/M4uHxNVKRKm5HPjkNZBnFA

在使用二维数组的时候,递推公式: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上,表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);

于其把dp[i - 1]这一层拷贝到dp[i]上,不如只用一个一维数组了,只用dp[j]（一维数组，也可以理解是一个滚动数组）

1.确定dp数组以及下标的含义

在一维dp数组中,dp[j]表示: 容量为j的背包,所背的物品价值可以最大为dp[j]

2.确定递推公式

dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

3.dp数组如何初始化

dp[0] = 0;

### 完全背包

有N件物品和一个最多能背重量为W的背包.第i件物品的重量是weight[i],得到的价值是value[i].
每件物品都有无限个(也就是可以放入背包多次),求解将哪些物品装入背包里物品价值总和最大

**完全背包和01背包问题唯一不同的地方就是,每种物品有无限件**

完全背包的dp公式与01背包一样都是: dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

01背包针对容量的循环是从大到小遍历,是为了保证每个物品仅被添加一次;而完全背包的物品是可以添加多次的,所以要从小到大去遍历


### 总结

- 01背包,容量为j的背包,所背的物品价值可以最大为dp[j]: dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
- 01背包,填满容量为j的背包,有dp[j]种方式: dp[j] += dp[j - nums[i]];dp[0] = 1
- 01背包和完全背包的遍历顺序不同,01背包针对容量的循环是从大到小遍历,是为了保证每个物品仅被添加一次;
而完全背包的物品是可以添加多次的,所以要从小到大去遍历
- 完全背包的dp公式与01背包相同,都是: dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
- 完全背包,填满容量为j的背包,有dp[j]种方式: dp[j] += dp[j - nums[i]];dp[0] = 1; 
这个公式与01背包相同,但是要注意遍历时的顺序
   1. 背包容量要正序遍历
   2. 如果先遍历物品,再遍历背包容量,则计算的是**组合数**;如果先遍历背包容量,再遍历物品,则计算的是**排列数**
