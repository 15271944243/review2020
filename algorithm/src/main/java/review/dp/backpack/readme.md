### 01背包
有N件物品和一个最多能被重量为W的背包,第i件物品的重量是weight[i],得到的价值是value[i]  
每件物品只能用一次,求解将哪些物品装入背包里物品价值总和最

> 因为每个物品只能使用一次,所以叫01背包

背包问题,除了暴力解法外,可以使用动态规划
#### 二维DP数组解法
https://mp.weixin.qq.com/s/FwIiPPmR18_AJO5eiidT6w

对于背包问题,有一种解法,是使用二维数组,即dp[i][j]表示从下标为[0-i]的物品里任意取,
放进容量为j的背包,价值总和最大是多少大

1.确定dp数组以及下标的含义

dp[i][j]表示从下标为[0-i]的物品里任意取,放进容量为j的背包,价值总和最大是多少大

2.确定递推公式
- 由dp[i - 1][j]推出,即背包容量为j,里面不放物品i的最大价值,此时dp[i][j]就是dp[i - 1][j]
- 由dp[i - 1][j - weight[i]]推出,dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值,
那么dp[i - 1][j - weight[i]] + value[i] (物品i的价值),就是背包放物品i得到的最大价值

所以递归公式(状态转移方程)：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

3.dp数组如何初始化

- 如果背包容量j为0的话,即dp[i][0],无论是选取哪些物品,背包价值总和一定为0
- i 是由 i-1 推导出来,那么i为0的时候就一定要初始化: dp[0][j],即i为0,存放编号0的物品的时候,各个容量的背包所能存放的最大价值
```
// 倒叙遍历  
for (int j = bagWeight; j >= weight[0]; j--) {  
    dp[0][j] = dp[0][j - weight[0]] + value[0]; // 初始化i为0时候的情况  
}
```
一定要倒叙遍历,保证物品0只被放入一次

4.确定遍历顺序

有两个遍历的维度: 物品与背包重量  
先遍历物品还是先遍历背包重量呢？ 其实都可以,但是先遍历物品更好理解

#### 一维dp数组（滚动数组）解法

https://mp.weixin.qq.com/s/M4uHxNVKRKm5HPjkNZBnFA

在使用二维数组的时候,递推公式: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上,表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);

于其把dp[i - 1]这一层拷贝到dp[i]上,不如只用一个一维数组了,只用dp[j]（一维数组，也可以理解是一个滚动数组）

1.确定dp数组以及下标的含义

在一维dp数组中,dp[j]表示: 容量为j的背包,所背的物品价值可以最大为dp[j]

2.确定递推公式

dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

3.dp数组如何初始化

dp[0] = 0;

### 完全背包




### 总结

- 容量为j的背包,所背的物品价值可以最大为dp[j]: dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
- 填满容量为j的背包,有dp[j]种方式: dp[j] += dp[j - nums[i]]